#!/usr/bin/env python3
# filepath: /Users/rainboy/.config/nvim/dotfiles/scripts/b

"""
快速编译脚本
g++ 编译脚本 author: rainboy
upd: 2024-08-25
  - 增加了 --help
  - 修改了 -d 参数为添加-DDEBUG编译宏
2024-01-01
"""

import argparse
import os
import sys
import subprocess
import glob
import curses
from pathlib import Path
import platform

VERSION = "20240825"
# 根据操作系统选择编译器
if platform.system() == "Darwin":  # macOS
    CXX = "clang++"
else:
    CXX = "g++"
CXXFLAG = ["-g"]

RED = "\033[31m"
GREEN = "\033[32m"
ENDCOLOR = "\033[0m"

def find_files(pattern):
    """查找匹配模式的文件"""
    return glob.glob(pattern, recursive=True)

def check_file_exists(file_path):
    """检查文件是否存在"""
    return os.path.exists(file_path)

def get_cxx_version():
    """检查C++支持的最高标准"""
    standards = ["20", "17", "14", "11"]
    for std in standards:
        try:
            # clang++ 需要不同的参数来检查标准支持
            if CXX == "clang++":
                result = subprocess.run(
                    [CXX, f"-std=c++{std}", "-E", "-x", "c++", "-"],
                    input="",
                    text=True,
                    capture_output=True,
                    timeout=10
                )
            else:  # g++
                result = subprocess.run(
                    [CXX, f"-std=c++{std}", "-dM", "-E", "-x", "c++", "-"],
                    input="",
                    text=True,
                    capture_output=True,
                    timeout=10
                )
            if result.returncode == 0:
                return std
        except subprocess.TimeoutExpired:
            continue
    return "11"  # 默认返回C++11

def select_file(files):
    """使用curses实现简单的文件选择器"""
    if not files:
        return None

    if len(files) == 1:
        return files[0]

    def draw_menu(stdscr):
        curses.curs_set(0)
        stdscr.clear()
        height, width = stdscr.getmaxyx()

        selected_idx = 0
        while True:
            stdscr.clear()
            stdscr.addstr(0, 0, "选择文件 (使用上下键导航, 回车确认, q退出):")

            for idx, file in enumerate(files):
                if idx >= height - 2:
                    break
                if idx == selected_idx:
                    stdscr.addstr(idx + 1, 0, f"> {file}", curses.A_REVERSE)
                else:
                    stdscr.addstr(idx + 1, 0, f"  {file}")

            stdscr.refresh()
            key = stdscr.getch()

            if key == curses.KEY_UP and selected_idx > 0:
                selected_idx -= 1
            elif key == curses.KEY_DOWN and selected_idx < len(files) - 1:
                selected_idx += 1
            elif key == ord('\n'):  # Enter
                return files[selected_idx]
            elif key == ord('q'):
                return None

    try:
        return curses.wrapper(draw_menu)
    except Exception:
        # 如果curses失败，返回第一个文件
        return files[0] if files else None

def compile_source(source_file, target_file, std_option, debug_flag):
    """编译源文件"""
    compile_args = [CXX] + CXXFLAG

    if std_option:
        compile_args.append(f"-std=c++{std_option}")

    if debug_flag:
        compile_args.append("-DDEBUG")

    compile_args.extend(["-o", target_file, source_file])

    print(" ".join(compile_args))

    try:
        result = subprocess.run(compile_args, check=True)
        if result.returncode == 0:
            print(f"编译成功 {target_file}")
            return True
        else:
            print("编译失败!")
            return False
    except subprocess.CalledProcessError:
        print("编译失败!")
        return False

def run_program(target_file, input_file, output_file):
    """运行程序"""
    run_args = [f"./{target_file}"]

    try:
        # 处理输入文件
        stdin_handle = None
        if input_file and os.path.exists(input_file):
            stdin_handle = open(input_file, 'r')
        
        # 处理输出文件
        stdout_handle = None
        if output_file:
            stdout_handle = open(output_file, 'w')
        
        try:
            if input_file and os.path.exists(input_file):
                print(f"执行代码: [ ./{target_file} < {input_file} ]")
                subprocess.run([f"./{target_file}"], stdin=stdin_handle, stdout=stdout_handle)
            else:
                print(f"执行代码: [ ./{target_file} ]")
                subprocess.run([f"./{target_file}"], stdout=stdout_handle)
        finally:
            # 确保文件句柄被正确关闭
            if stdin_handle:
                stdin_handle.close()
            if stdout_handle:
                stdout_handle.close()
                
    except Exception as e:
        print(f"运行程序时出错: {e}")

def main():
    parser = argparse.ArgumentParser(description="g++ 编译脚本")
    parser.add_argument("source_file", nargs="?", help="源文件")
    parser.add_argument("-i", "--input-file", help="输入文件,默认为in")
    parser.add_argument("-o", "--output-file", help="输出文件")
    parser.add_argument("-c", "--choose-input", action="store_true", help="选择输入文件")
    parser.add_argument("-I", "--no-input", action="store_true", help="不需要输入文件")
    parser.add_argument("-d", "--debug", action="store_true", help="添加编译宏 -DDEBUG")
    parser.add_argument("-s", "--std", help="编译标准,如11,14,17,20")
    parser.add_argument("-n", "--norun", action="store_true", help="编译后不要运行")
    parser.add_argument("-v", "--version", action="version", version=f"version: {VERSION}")

    args = parser.parse_args()

    # 处理源文件
    source_file = args.source_file
    if not source_file:
        cpp_files = find_files("*.cpp")
        source_file = select_file(cpp_files)
        if not source_file:
            print("未选择源文件")
            return 1

    # 确保源文件以.cpp结尾
    if not source_file.endswith(".cpp"):
        source_file = f"{source_file}.cpp"

    if not check_file_exists(source_file):
        print(f">>> 源码: [ {source_file } ] 不存在!")
        return 1

    # 确定目标文件
    target_file = f"{source_file[:-4]}_debug.out" if args.debug else f"{source_file[:-4]}.out"

    # 处理输入文件
    input_file = args.input_file or "in"
    if args.choose_input:
        input_files = find_files("*in*")
        input_file = select_file(input_files)
    elif not args.no_input and not check_file_exists(input_file):
        input_files = find_files("*in*")
        input_file = select_file(input_files)

    # 检查C++标准
    std_option = args.std or get_cxx_version()

    # 编译
    if not os.path.exists(target_file) or os.path.getmtime(source_file) > os.path.getmtime(target_file):
        if not compile_source(source_file, target_file, std_option, args.debug):
            return 1
    else:
        print(f">>> 源码 {source_file} 没有 {target_file} 新,不编译")

    # 运行
    if args.norun:
        return 0

    if not args.no_input and input_file and not check_file_exists(input_file):
        do_run = input("输入文件为[空] 或 [不存在],是否执行代码[Y/n]? ").strip().lower()
        if do_run in ['n', 'no']:
            return 0

    run_program(target_file, input_file, args.output_file)

    return 0

if __name__ == "__main__":
    sys.exit(main())